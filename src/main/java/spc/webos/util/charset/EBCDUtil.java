package spc.webos.util.charset;

import java.io.ByteArrayOutputStream;
import java.io.UnsupportedEncodingException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import spc.webos.constant.Common;
import spc.webos.util.StringX;

public class EBCDUtil
{
	static Logger log = LoggerFactory.getLogger(EBCDUtil.class);

	public static class CH_WORD
	{
		int h;
		int l;
	}

	public static byte[] int2char(int ch)
	{
		return new byte[] { (byte) ((ch >>> 8) & 0XFF), (byte) (ch & 0XFF) };
	}

	public static int char2int(byte[] ch)
	{
		int h = ch[0] & 0XFF, l = ch[1] & 0XFF;
		return (h << 8) + l;
	}

	public static int char2int(byte s1, byte s2)
	{
		int h = s1 & 0XFF, l = s2 & 0XFF;
		return (h << 8) + l;
	}

	// 本文件对外只提供两个函数 asc2ebc, ebc2asc
	public static boolean is_GBK(int x)
	{
		return (x > 0x80) ? true : false;
	}

	public static boolean is_EBC_chinese_begin(int x)
	{
		return (x == 0x0E) ? true : false;
	}

	public static boolean is_EBC_chinese_end(int x)
	{
		return (x == 0x0F) ? true : false;
	}

	// TURN CODE UNIX(ASCII & GBK ) to AS400( EBCDIC )

	public static byte[] GBK_to_EBC(int s1, int s2)
	{
		CH_WORD wi = new CH_WORD();
		wi.h = s1;
		wi.l = s2 & 0xFF;
		CH_WORD wo = GBK_to_EBC(wi);
		return new byte[] { (byte) wo.h, (byte) wo.l };
	}

	public static byte[] EBC_to_GBK(int s1, int s2)
	{
		CH_WORD wi = new CH_WORD();
		wi.h = s1;
		wi.l = s2 & 0xFF;
		CH_WORD wo = EBC_to_GBK(wi);
		return new byte[] { (byte) wo.h, (byte) wo.l };
	}

	public static byte[] gbk2bcd(String gbk)
	{
		return gbk2bcd(gbk, true);
	}

	public static byte[] gbk2bcd(String gbk, boolean blankAdjust)
	{
		byte[] in = null;
		try
		{
			in = gbk.getBytes("GBK");
		}
		catch (Exception e)
		{
			throw new RuntimeException(e);
		}
		int i, o = 0;
		int ch;
		CH_WORD wi, wo;
		int num_of_space_for_chinese = 0;
		ByteArrayOutputStream outstream = new ByteArrayOutputStream();
		wi = new CH_WORD();
		for (i = 0; i < in.length; i++)
		{
			ch = in[i] & 0xFF;
			// System.out.println("cch:[" + String.valueOf((char) ch) + "][" +
			// ch + "]" + i + "["
			// + in.length);
			if (is_GBK(ch))
			{
				outstream.write(0x0E);
				o++;
				while ((i < in.length) && is_GBK(ch))
				{
					wi.h = ch;
					wi.l = in[++i] & 0xFF;

					wo = GBK_to_EBC(wi);
					outstream.write(wo.h);
					o++;
					outstream.write(wo.l);
					o++;
					i++;
					if (i < in.length) ch = in[i] & 0xFF;
					else break;
				}
				outstream.write(0x0F);
				o++;
				i--;
				num_of_space_for_chinese = num_of_space_for_chinese + 2;
			}
			else
			{
				// 由于转码时针对汉字前后加 0x0e 和 0x0f
				// 所以长度会增加,为了转码后列的偏移能对齐
				// 相应的缩减空格
				if (blankAdjust && ch == 0x20)
				{
					if (num_of_space_for_chinese != 0)
					{
						num_of_space_for_chinese--;
						continue;
					}
				}
				else
				{
					if (ch == '\n')
					{ // 2006-07-24 增加
						// 换行以后重新计数空格
						// 原来针对一行转码,所以没问题.
						// 但是现在直接对一个文本文件按块转码,
						// 当遇到回车以后应该重新计数空格
						num_of_space_for_chinese = 0;
					}
				}
				// System.out.println("ch:[" + String.valueOf((char) ch) + "]["
				// + ch + "]");

				outstream.write(char_a2e(ch));
				o++;
			}
		}
		// len = o;
		byte[] out = outstream.toByteArray();
		try
		{
			outstream.close();
		}
		catch (Exception e)
		{
		}
		return out;
	}

	// TURN CODE AS400( EBCDIC ) to UNIX(ASCII & GBK )
	public static String bcd2gbk(byte[] in)
	{
		return bcd2gbk(in, 0, in.length, true);
	}

	public static String bcd2gbk(byte[] in, int offset, int len)
	{
		return bcd2gbk(in, offset, len, true);
	}

	public static String bcd2gbk(byte[] in, int offset, int len, boolean blankAdjust)
	{
		// int o = 0;
		int ch;
//		int num_of_space_for_chinese = 0;
		CH_WORD wi, wo;
		ByteArrayOutputStream outstream = new ByteArrayOutputStream();
		wi = new CH_WORD();
		for (int i = offset; i < offset + len; i++)
		{
			ch = in[i] & 0xFF;
			if (is_EBC_chinese_begin(ch))
			{
				do
				{ // 2012-07-31 容许汉字前出现多个0E 0E
					i++;
					if (i >= in.length) break;
					ch = in[i] & 0xFF;
				}
				while (is_EBC_chinese_begin(ch));
				if (i >= in.length) break;

				while ((i < in.length) && !(is_EBC_chinese_end(ch)))
				{
					wi.h = ch;
					// 2012-07-31 有可能汉字BCD只送了一半的字节，则程序忽视
					if (i == in.length - 1)
					{
						log.warn("half CN byte!!!");
						break;
					}
					wi.l = in[++i] & 0xFF;
					wo = EBC_to_GBK(wi);
					if (wo != null)
					{
						outstream.write(wo.h);
						// o++;
						outstream.write(wo.l);
						// o++;
					}
					else
					{
						outstream.write(0x20);
						// o++;
						outstream.write(0x20);
						// o++;
					}
					// 2012-07-31 有可能汉字没有0f结尾
					if (i < in.length - 1) ch = in[++i] & 0xFF;
					else
					{
						log.warn("CN without '0F' end !!!");
						++i;
					}
				}
				// 转换输入的EBCDIC汉字双字节字符串后,
				// 转换后的ASCII汉字符串要增加两个空格
				if (blankAdjust)
				{
					outstream.write(0x20);
					// o++;
					outstream.write(0x20);
					// o++;
				}
//				num_of_space_for_chinese += 2; // 空格补位并不是在汉字后面而是汉字后面出现空格的位置开始补
			}
			else if (is_EBC_chinese_end(ch))
			{ // 2012-07-31天农商碰到汉字0F汉字结尾标志不匹配，多了很多0f, 程序忽视0f
				log.warn("unmatched '0F', replaced with 0x20 !!!");
				outstream.write(0x20); // 使用空格补位
			}
			else
			{
				// chenjs 2012-08-01, 根据TRC情况，使用方案二
				// 方案: 1. 汉字介绍后碰到第一个空格时补空格，这样可以保证空格在最后, in[i] == 0x40
				// 2. 汉字一结束就补空格 is_EBC_chinese_end(in[i-1])
				// if (blankAdjust && is_EBC_chinese_end(in[i - 1]))
				// {
				// for (int j = num_of_space_for_chinese; j > 0; j--)
				// outstream.write(0x20);
				// num_of_space_for_chinese = 0;
				// // continue;
				// }
				outstream.write(char_e2a(ch));
				// o++;
			}
		}
		// out[o] = '\0';
		byte[] out = outstream.toByteArray();
		try
		{
			outstream.close();
		}
		catch (Exception e)
		{
		}
		try
		{
			return new String(out, "GBK");
		}
		catch (UnsupportedEncodingException e)
		{
			throw new RuntimeException(e);
		}
	}

	private static int[][] GBK1_to_EBC1_Table = {

			// 第 1 区
			{
					0x40,
					0x40,
					0x43,
					0x44,
					0x43,
					0x41,
					0x43,
					0x45,
					0x45,
					0x45,
					0x45,
					0x46,
					0x44,
					0x60,
					// 2012-3-22参考TRC,第26位的0x40--->0x7f
					0x44,
					0x5B,
					0x44,
					0x5D,
					0x44,
					0x4A,
					0x43,
					0xA1,
					0x44,
					0x7C,
					0x44,
					0x7f,
					0x44,
					// 0x44, 0x5B, 0x44, 0x5D, 0x44, 0x4A, 0x43, 0xA1, 0x44,
					// 0x7C, 0x44, 0x40, 0x44,
					0x61, 0x44, 0x71, 0x44, 0x62, 0x44, 0x72, 0x44, 0x63, 0x44, 0x73, 0x44, 0x64,
					0x44, 0x74, 0x44, 0x65, 0x44, 0x75, 0x43, 0x42, 0x43, 0x43, 0x44, 0x42, 0x44,
					0x43, 0x45, 0x5B, 0x45, 0x5C, 0x44, 0x66, 0x44, 0x76, 0x44, 0x4B, 0x44, 0x7A,
					0x44, 0x7B, 0x45, 0x62, 0x45, 0x63, 0x45, 0x64, 0x45, 0x65, 0x45, 0x66, 0x45,
					0x67, 0x45, 0x68, 0x45, 0x69, 0x45, 0x6A, 0x45, 0x6B, 0x45, 0x6C, 0x45, 0x6D,
					0x45, 0x6E, 0x45, 0x6F, 0x45, 0x70, 0x45, 0x71, 0x45, 0x72, 0x45, 0x73, 0x45,
					0x74, 0x45, 0x75, 0x45, 0x76, 0x45, 0x77, 0x44, 0x4C, 0x45, 0x79, 0x45, 0x7A,
					0x44, 0x67, 0x44, 0x77, 0x44, 0x4D, 0x44, 0x78, 0x44, 0x68, 0x44, 0x69, 0x44,
					0x79, 0x44, 0xED, 0x44, 0xEE, 0x44, 0xEF, 0x44, 0x4E, 0x42, 0xE0, 0x45, 0x88,
					0x43, 0x4A, 0x42, 0x4A, 0x45, 0x8B, 0x44, 0x6A, 0x44, 0x6E, 0x44, 0xE5, 0x44,
					0xE6, 0x44, 0xE0, 0x44, 0xE1, 0x44, 0xE4, 0x44, 0xE7, 0x44, 0xE8, 0x44, 0xE9,
					0x44, 0xEA, 0x44, 0xE2, 0x44, 0xE3, 0x44, 0x6B, 0x44, 0xF0, 0x44, 0xF1, 0x44,
					0xF2, 0x44, 0xF3, 0x44, 0x7D },

			// 第 2 区
			{ 0x41, 0xB1, 0x41, 0xB2, 0x41, 0xB3, 0x41, 0xB4, 0x41, 0xB5, 0x41, 0xB6, 0x41, 0xB7,
					0x41, 0xB8, 0x41, 0xB9, 0x41, 0xBA, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x45, 0xB1, 0x45, 0xB2, 0x45, 0xB3, 0x45, 0xB4,
					0x45, 0xB5, 0x45, 0xB6, 0x45, 0xB7, 0x45, 0xB8, 0x45, 0xB9, 0x45, 0xBA, 0x45,
					0xBB, 0x45, 0xBC, 0x45, 0xBD, 0x45, 0xBE, 0x45, 0xBF, 0x45, 0xC0, 0x45, 0xC1,
					0x45, 0xC2, 0x45, 0xC3, 0x45, 0xC4, 0x45, 0xC5, 0x45, 0xC6, 0x45, 0xC7, 0x45,
					0xC8, 0x45, 0xC9, 0x45, 0xCA, 0x45, 0xCB, 0x45, 0xCC, 0x45, 0xCD, 0x45, 0xCE,
					0x45, 0xCF, 0x45, 0xD0, 0x45, 0xD1, 0x45, 0xD2, 0x45, 0xD3, 0x45, 0xD4, 0x45,
					0xD5, 0x45, 0xD6, 0x45, 0xD7, 0x45, 0xD8, 0x45, 0xE1, 0x45, 0xE2, 0x45, 0xE3,
					0x45, 0xE4, 0x45, 0xE5, 0x45, 0xE6, 0x45, 0xE7, 0x45, 0xE8, 0x45, 0xE9, 0x45,
					0xEA, 0xFE, 0xFE, 0xFE, 0xFE, 0x45, 0xF1, 0x45, 0xF2, 0x45, 0xF3, 0x45, 0xF4,
					0x45, 0xF5, 0x45, 0xF6, 0x45, 0xF7, 0x45, 0xF8, 0x45, 0xF9, 0x45, 0xFA, 0xFE,
					0xFE, 0xFE, 0xFE, 0x41, 0xF1, 0x41, 0xF2, 0x41, 0xF3, 0x41, 0xF4, 0x41, 0xF5,
					0x41, 0xF6, 0x41, 0xF7, 0x41, 0xF8, 0x41, 0xF9, 0x41, 0xFA, 0x41, 0xFB, 0x41,
					0xFC, 0xFE, 0xFE, 0xFE, 0xFE },

			// 第 3 区
			// 2012-3-22参考TRC,第4位的0x40--->0x7f
			{
					0x42,
					0x5A,
					0x42,
					0x7f,
					0x42,
					0x7B,
					0x42,
					0x5B,
					0x42,
					0x6C,
					0x42,
					0x50,
					0x44,
					0x50,
					// { 0x42, 0x5A, 0x42, 0x40, 0x42, 0x7B, 0x42, 0x5B, 0x42,
					// 0x6C, 0x42, 0x50, 0x44, 0x50,
					0x42, 0x4D, 0x42, 0x5D, 0x42, 0x5C, 0x42, 0x4E, 0x42, 0x6B, 0x42, 0x60, 0x42,
					0x4B, 0x42, 0x61, 0x42, 0xF0, 0x42, 0xF1, 0x42, 0xF2, 0x42, 0xF3, 0x42, 0xF4,
					0x42, 0xF5, 0x42, 0xF6, 0x42, 0xF7, 0x42, 0xF8, 0x42, 0xF9, 0x42, 0x7A, 0x42,
					0x5E, 0x42, 0x4C, 0x42, 0x7E, 0x42, 0x6E, 0x42, 0x6F, 0x42, 0x7C, 0x42, 0xC1,
					0x42, 0xC2, 0x42, 0xC3, 0x42, 0xC4, 0x42, 0xC5, 0x42, 0xC6, 0x42, 0xC7, 0x42,
					0xC8, 0x42, 0xC9, 0x42, 0xD1, 0x42, 0xD2, 0x42, 0xD3, 0x42, 0xD4, 0x42, 0xD5,
					0x42, 0xD6, 0x42, 0xD7, 0x42, 0xD8, 0x42, 0xD9, 0x42, 0xE2, 0x42, 0xE3, 0x42,
					0xE4, 0x42, 0xE5, 0x42, 0xE6, 0x42, 0xE7, 0x42, 0xE8, 0x42, 0xE9, 0x44, 0x44,
					0x43, 0xE0, 0x44, 0x45, 0x44, 0x70, 0x42, 0x6D, 0x42, 0x79, 0x42, 0x81, 0x42,
					0x82, 0x42, 0x83, 0x42, 0x84, 0x42, 0x85, 0x42, 0x86, 0x42, 0x87, 0x42, 0x88,
					0x42, 0x89, 0x42, 0x91, 0x42, 0x92, 0x42, 0x93, 0x42, 0x94, 0x42, 0x95, 0x42,
					0x96, 0x42, 0x97, 0x42, 0x98, 0x42, 0x99, 0x42, 0xA2, 0x42, 0xA3, 0x42, 0xA4,
					0x42, 0xA5, 0x42, 0xA6, 0x42, 0xA7, 0x42, 0xA8, 0x42, 0xA9, 0x42, 0xC0, 0x42,
					0x4F, 0x42, 0xD0, 0x42, 0xA1 },

			// 第 4 区
			{ 0x44, 0x47, 0x44, 0x81, 0x44, 0x48, 0x44, 0x82, 0x44, 0x49, 0x44, 0x83, 0x44, 0x51,
					0x44, 0x84, 0x44, 0x52, 0x44, 0x85, 0x44, 0x86, 0x44, 0xC0, 0x44, 0x87, 0x44,
					0xC1, 0x44, 0x88, 0x44, 0xC2, 0x44, 0x89, 0x44, 0xC3, 0x44, 0x8A, 0x44, 0xC4,
					0x44, 0x8C, 0x44, 0xC5, 0x44, 0x8D, 0x44, 0xC6, 0x44, 0x8E, 0x44, 0xC7, 0x44,
					0x8F, 0x44, 0xC8, 0x44, 0x90, 0x44, 0xC9, 0x44, 0x91, 0x44, 0xCA, 0x44, 0x92,
					0x44, 0xCB, 0x44, 0x56, 0x44, 0x93, 0x44, 0xCC, 0x44, 0x94, 0x44, 0xCD, 0x44,
					0x95, 0x44, 0xCE, 0x44, 0x96, 0x44, 0x97, 0x44, 0x98, 0x44, 0x99, 0x44, 0x9A,
					0x44, 0x9D, 0x44, 0xCF, 0x44, 0xD5, 0x44, 0x9E, 0x44, 0xD0, 0x44, 0xD6, 0x44,
					0x9F, 0x44, 0xD1, 0x44, 0xD7, 0x44, 0xA2, 0x44, 0xD2, 0x44, 0xD8, 0x44, 0xA3,
					0x44, 0xD3, 0x44, 0xD9, 0x44, 0xA4, 0x44, 0xA5, 0x44, 0xA6, 0x44, 0xA7, 0x44,
					0xA8, 0x44, 0x53, 0x44, 0xA9, 0x44, 0x54, 0x44, 0xAA, 0x44, 0x55, 0x44, 0xAC,
					0x44, 0xAD, 0x44, 0xAE, 0x44, 0xAF, 0x44, 0xBA, 0x44, 0xBB, 0x44, 0x57, 0x44,
					0xBC, 0x44, 0xDA, 0x44, 0xDB, 0x44, 0x46, 0x44, 0xBD, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE },

			// 第 5 区
			{ 0x43, 0x47, 0x43, 0x81, 0x43, 0x48, 0x43, 0x82, 0x43, 0x49, 0x43, 0x83, 0x43, 0x51,
					0x43, 0x84, 0x43, 0x52, 0x43, 0x85, 0x43, 0x86, 0x43, 0xC0, 0x43, 0x87, 0x43,
					0xC1, 0x43, 0x88, 0x43, 0xC2, 0x43, 0x89, 0x43, 0xC3, 0x43, 0x8A, 0x43, 0xC4,
					0x43, 0x8C, 0x43, 0xC5, 0x43, 0x8D, 0x43, 0xC6, 0x43, 0x8E, 0x43, 0xC7, 0x43,
					0x8F, 0x43, 0xC8, 0x43, 0x90, 0x43, 0xC9, 0x43, 0x91, 0x43, 0xCA, 0x43, 0x92,
					0x43, 0xCB, 0x43, 0x56, 0x43, 0x93, 0x43, 0xCC, 0x43, 0x94, 0x43, 0xCD, 0x43,
					0x95, 0x43, 0xCE, 0x43, 0x96, 0x43, 0x97, 0x43, 0x98, 0x43, 0x99, 0x43, 0x9A,
					0x43, 0x9D, 0x43, 0xCF, 0x43, 0xD5, 0x43, 0x9E, 0x43, 0xD0, 0x43, 0xD6, 0x43,
					0x9F, 0x43, 0xD1, 0x43, 0xD7, 0x43, 0xA2, 0x43, 0xD2, 0x43, 0xD8, 0x43, 0xA3,
					0x43, 0xD3, 0x43, 0xD9, 0x43, 0xA4, 0x43, 0xA5, 0x43, 0xA6, 0x43, 0xA7, 0x43,
					0xA8, 0x43, 0x53, 0x43, 0xA9, 0x43, 0x54, 0x43, 0xAA, 0x43, 0x55, 0x43, 0xAC,
					0x43, 0xAD, 0x43, 0xAE, 0x43, 0xAF, 0x43, 0xBA, 0x43, 0xBB, 0x43, 0x57, 0x43,
					0xBC, 0x43, 0xDA, 0x43, 0xDB, 0x43, 0x46, 0x43, 0xBD, 0x43, 0xD4, 0x43, 0x59,
					0x43, 0x5A, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE },

			// 第 6 区
			{ 0x41, 0x61, 0x41, 0x62, 0x41, 0x63, 0x41, 0x64, 0x41, 0x65, 0x41, 0x66, 0x41, 0x67,
					0x41, 0x68, 0x41, 0x69, 0x41, 0x6A, 0x41, 0x6B, 0x41, 0x6C, 0x41, 0x6D, 0x41,
					0x6E, 0x41, 0x6F, 0x41, 0x70, 0x41, 0x71, 0x41, 0x72, 0x41, 0x73, 0x41, 0x74,
					0x41, 0x75, 0x41, 0x76, 0x41, 0x77, 0x41, 0x78, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x41, 0x41,
					0x41, 0x42, 0x41, 0x43, 0x41, 0x44, 0x41, 0x45, 0x41, 0x46, 0x41, 0x47, 0x41,
					0x48, 0x41, 0x49, 0x41, 0x4A, 0x41, 0x4B, 0x41, 0x4C, 0x41, 0x4D, 0x41, 0x4E,
					0x41, 0x4F, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41,
					0x55, 0x41, 0x56, 0x41, 0x57, 0x41, 0x58, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x47, 0x41, 0x47, 0x42, 0x47,
					0x43, 0x47, 0x44, 0x47, 0x45, 0x47, 0x46, 0x47, 0x47, 0x47, 0x48, 0x47, 0x49,
					0x47, 0x4A, 0x47, 0x4B, 0x47, 0x4C, 0xFE, 0xFE, 0xFE, 0xFE, 0x47, 0x4D, 0x47,
					0x4E, 0x47, 0x4F, 0x47, 0x50, 0x47, 0x51, 0xFE, 0xFE, 0x47, 0x52, 0x47, 0x53,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE },

			// 第 7 区
			{ 0x41, 0xC0, 0x41, 0xC1, 0x41, 0xC2, 0x41, 0xC3, 0x41, 0xC4, 0x41, 0xC5, 0x41, 0xC6,
					0x41, 0xC7, 0x41, 0xC8, 0x41, 0xC9, 0x41, 0xCA, 0x41, 0xCB, 0x41, 0xCC, 0x41,
					0xCD, 0x41, 0xCE, 0x41, 0xCF, 0x41, 0xD0, 0x41, 0xD1, 0x41, 0xD2, 0x41, 0xD3,
					0x41, 0xD4, 0x41, 0xD5, 0x41, 0xD6, 0x41, 0xD7, 0x41, 0xD8, 0x41, 0xD9, 0x41,
					0xDA, 0x41, 0xDB, 0x41, 0xDC, 0x41, 0xDD, 0x41, 0xDE, 0x41, 0xDF, 0x41, 0xE0,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0x41, 0x80, 0x41, 0x81, 0x41, 0x82, 0x41, 0x83, 0x41,
					0x84, 0x41, 0x85, 0x41, 0x86, 0x41, 0x87, 0x41, 0x88, 0x41, 0x89, 0x41, 0x8A,
					0x41, 0x8B, 0x41, 0x8C, 0x41, 0x8D, 0x41, 0x8E, 0x41, 0x8F, 0x41, 0x90, 0x41,
					0x91, 0x41, 0x92, 0x41, 0x93, 0x41, 0x94, 0x41, 0x95, 0x41, 0x96, 0x41, 0x97,
					0x41, 0x98, 0x41, 0x99, 0x41, 0x9A, 0x41, 0x9B, 0x41, 0x9C, 0x41, 0x9D, 0x41,
					0x9E, 0x41, 0x9F, 0x41, 0xA0, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE },

			// 第 8 区
			{ 0x46, 0x41, 0x46, 0x42, 0x46, 0x43, 0x46, 0x44, 0x46, 0x45, 0x46, 0x46, 0x46, 0x47,
					0x46, 0x48, 0x46, 0x49, 0x46, 0x4A, 0x46, 0x4B, 0x46, 0x4C, 0x46, 0x4D, 0x46,
					0x4E, 0x46, 0x4F, 0x46, 0x50, 0x46, 0x51, 0x46, 0x52, 0x46, 0x53, 0x46, 0x54,
					0x46, 0x55, 0x46, 0x56, 0x46, 0x57, 0x46, 0x58, 0x46, 0x59, 0x46, 0x5A, 0x46,
					0x5B, 0x46, 0x5C, 0x46, 0x5D, 0x46, 0x5E, 0x46, 0x5F, 0x46, 0x60, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x46, 0x65, 0x46, 0x66, 0x46, 0x67, 0x46,
					0x68, 0x46, 0x69, 0x46, 0x6A, 0x46, 0x6B, 0x46, 0x6C, 0x46, 0x6D, 0x46, 0x6E,
					0x46, 0x6F, 0x46, 0x70, 0x46, 0x71, 0x46, 0x72, 0x46, 0x73, 0x46, 0x74, 0x46,
					0x75, 0x46, 0x76, 0x46, 0x77, 0x46, 0x78, 0x46, 0x79, 0x46,
					0x7A,
					0x46,
					0x7B,
					// 2012-3-22参考TRC,第126位的0x40--->0x7f
					0x46, 0x7C, 0x46, 0x7D, 0x46, 0x7E,
					0x46,
					0x7f,
					0x46,
					0x80,
					0x46,
					0x81,
					0x46,
					// 0x46, 0x7C, 0x46, 0x7D, 0x46, 0x7E, 0x46, 0x40, 0x46,
					// 0x80, 0x46, 0x81, 0x46,
					0x82, 0x46, 0x83, 0x46, 0x84, 0x46, 0x85, 0x46, 0x86, 0x46, 0x87, 0x46, 0x88,
					0x46, 0x89, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE },

			// 第 9 区
			{ 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x46, 0xA4, 0x46, 0xA5, 0x46, 0xA6, 0x46, 0xA7,
					0x46, 0xA8, 0x46, 0xA9, 0x46, 0xAA, 0x46, 0xAB, 0x46, 0xAC, 0x46, 0xAD, 0x46,
					0xAE, 0x46, 0xAF, 0x46, 0xB0, 0x46, 0xB1, 0x46, 0xB2, 0x46, 0xB3, 0x46, 0xB4,
					0x46, 0xB5, 0x46, 0xB6, 0x46, 0xB7, 0x46, 0xB8, 0x46, 0xB9, 0x46, 0xBA, 0x46,
					0xBB, 0x46, 0xBC, 0x46, 0xBD, 0x46, 0xBE, 0x46, 0xBF, 0x46, 0xC0, 0x46, 0xC1,
					0x46, 0xC2, 0x46, 0xC3, 0x46, 0xC4, 0x46, 0xC5, 0x46, 0xC6, 0x46, 0xC7, 0x46,
					0xC8, 0x46, 0xC9, 0x46, 0xCA, 0x46, 0xCB, 0x46, 0xCC, 0x46, 0xCD, 0x46, 0xCE,
					0x46, 0xCF, 0x46, 0xD0, 0x46, 0xD1, 0x46, 0xD2, 0x46, 0xD3, 0x46, 0xD4, 0x46,
					0xD5, 0x46, 0xD6, 0x46, 0xD7, 0x46, 0xD8, 0x46, 0xD9, 0x46, 0xDA, 0x46, 0xDB,
					0x46, 0xDC, 0x46, 0xDD, 0x46, 0xDE, 0x46, 0xDF, 0x46, 0xE0, 0x46, 0xE1, 0x46,
					0xE2, 0x46, 0xE3, 0x46, 0xE4, 0x46, 0xE5, 0x46, 0xE6, 0x46, 0xE7, 0x46, 0xE8,
					0x46, 0xE9, 0x46, 0xEA, 0x46, 0xEB, 0x46, 0xEC, 0x46, 0xED, 0x46, 0xEE, 0x46,
					0xEF, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE } };

	// static byte[][] GBK5_to_EBC5_Table[2][194] = {
	private static int[][] GBK5_to_EBC5_Table = {
			{ 0xCD, 0x41, 0xCD, 0x42, 0xCD, 0x43, 0xCD, 0x44, 0xCD, 0x45, 0x44, 0x7E, 0xCD, 0x46,
					0xCD, 0x47, 0xCD, 0x48, 0xCD, 0x49, 0xCD, 0x4A, 0xCD, 0x4B, 0xCD, 0x4C, 0xCD,
					0x4D, 0xCD, 0x4E, 0xCD, 0x4F, 0xCD, 0x50, 0xCD, 0x51, 0xCD, 0x52, 0xCD, 0x53,
					0xCD, 0x54, 0xCD, 0x55, 0xCD, 0x56, 0xCD, 0x57, 0xCD, 0x58, 0xCD, 0x59, 0xCD,
					0x5A, 0xCD, 0x5B, 0xCD, 0x5C, 0xCD, 0x5D, 0xCD, 0x5E, 0xCD, 0x5F, 0xCD, 0x60,
					0xCD, 0x61, 0xCD, 0x62, 0xCD, 0x63, 0xCD, 0x64, 0xCD, 0x65, 0xCD, 0x66, 0xCD,
					0x67, 0xCD, 0x68, 0xCD, 0x69, 0xCD, 0x6A, 0xCD, 0x6B, 0xCD, 0x6C, 0xCD, 0x6D,
					0xCD, 0x6E, 0xCD, 0x6F, 0xCD, 0x70, 0xCD, 0x71, 0xCD, 0x72, 0xCD, 0x73, 0xCD,
					0x74, 0xCD, 0x75, 0xCD, 0x76, 0xCD, 0x77, 0xCD, 0x78, 0xCD,
					0x79,
					0xCD,
					0x7A,
					// 2012-3-22参考TRC,第130位的0x40--->0x7f
					0xCD, 0x7B, 0xCD, 0x7C, 0xCD, 0x7D,
					0xCD,
					0x7E,
					0xFE,
					0xFE,
					0xCD,
					0x7f,
					0xCD,
					// 0xCD, 0x7B, 0xCD, 0x7C, 0xCD, 0x7D, 0xCD, 0x7E, 0xFE,
					// 0xFE, 0xCD, 0x40, 0xCD,
					0x81, 0xCD, 0x82, 0xCD, 0x83, 0xCD, 0x84, 0xCD, 0x85, 0xCD, 0x86, 0xCD, 0x87,
					0xCD, 0x88, 0xCD, 0x89, 0xCD, 0x8A, 0x44, 0xEC, 0x44, 0xEB, 0xCD, 0x8B, 0xCD,
					0x8C, 0xCD, 0x8D, 0xCD, 0x8E, 0xCD, 0x8F, 0xCD, 0x90, 0x44, 0x6C, 0xCD, 0x91,
					0xCD, 0x92, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE },
			{ 0xCD, 0x93, 0xCD, 0x94, 0xCD, 0x95, 0xCD, 0x96, 0xCD, 0x97, 0xCD, 0x98, 0xCD, 0x99,
					0xCD, 0x9A, 0xCD, 0x9B, 0xCD, 0x9C, 0xCD, 0x9D, 0xCD, 0x9E, 0xCD, 0x9F, 0xCD,
					0xA0, 0xCD, 0xA1, 0xCD, 0xA2, 0xCD, 0xA3, 0xCD, 0xA4, 0xCD, 0xA5, 0xCD, 0xA6,
					0xCD, 0xA7, 0xCD, 0xA8, 0x42, 0x5F, 0x42, 0x6A, 0xFE, 0xFE, 0x44, 0x6F, 0x44,
					0x6D, 0xFE, 0xFE, 0x44, 0x5A, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x43, 0x58,
					0x43, 0xBE, 0x43, 0xBF, 0x43, 0xDC, 0x43, 0xDD, 0x44, 0x5E, 0x44, 0xDC, 0x44,
					0xDD, 0xCD, 0xA9, 0xCD, 0xAA, 0xCD, 0xAB, 0xCD, 0xAC, 0xCD, 0xAD, 0xCD, 0xAE,
					0xCD, 0xAF, 0xCD, 0xB0, 0xCD, 0xB1, 0xCD, 0xB2, 0xCD, 0xB3, 0xCD, 0xB4, 0xCD,
					0xB5, 0xCD, 0xB6, 0xCD, 0xB7, 0xCD, 0xB8, 0xCD, 0xB9, 0xCD, 0xBA, 0xCD, 0xBB,
					0xCD, 0xBC, 0xCD, 0xBD, 0xCD, 0xBE, 0xCD, 0xBF, 0xFE, 0xFE, 0xCD, 0xC0, 0xCD,
					0xC1, 0xCD, 0xC2, 0xCD, 0xC3, 0xCD, 0xC4, 0xCD, 0xC5, 0xCD, 0xC6, 0xCD, 0xC7,
					0xCD, 0xC8, 0xCD, 0xC9, 0xCD, 0xCA, 0xCD, 0xCB, 0xCD, 0xCC, 0xCD, 0xCD, 0xCD,
					0xCE, 0xCD, 0xCF, 0xCD, 0xD0, 0xCD, 0xD1, 0xCD, 0xD2, 0xCD, 0xD3, 0xCD, 0xD4,
					0xCD, 0xD5, 0x44, 0x5F, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
					0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE } };

	// GBK/1: GB2312 - 符号区
	// GBK : A1A1 --> A9FE
	private static boolean is_GBK1(CH_WORD i)
	{
		if (i.h >= 0xa1 && i.h <= 0xa9)
		{
			if (i.l >= 0xa1 && i.l <= 0xfe) return true;
		}
		return false;
	}

	// GBK/2: GB2312 基本集 ( 6768 个汉字 )
	// GBK : B0A1 --> F7FE
	private static boolean is_GBK2(CH_WORD i)
	{
		if (i.h >= 0xb0 && i.h <= 0xf7)
		{
			if (i.l >= 0xa1 && i.l <= 0xfe) return true;
		}
		return false;
	}

	// GBK/3 第 3 区 -> EBCDIC
	// GBK: 0x8140 --> 0xA0FE ( 不包括 xx7F )
	private static boolean is_GBK3(CH_WORD i)
	{
		if (i.h >= 0x81 && i.h <= 0xa0)
		{
			if (i.l >= 0x40 && i.l <= 0xfe && i.l != 0x7f) { return true; }
		}
		return false;
	}

	// GBK/4 第 4 区 -> EBCDIC
	// GBK: 0xAA40 --> 0xFEA0 ( 不包括 xx7F )
	public static boolean is_GBK4(CH_WORD i)
	{
		if (i.h >= 0xaa && i.h <= 0xfe)
		{
			if (i.l >= 0x40 && i.l <= 0xa0 && i.l != 0x7f) return true;
		}
		return false;
	}

	// GBK/5 第 5 区
	// GBK: 0xA840 --> 0xA9A0 ( 不包括 xx7F )
	public static boolean is_GBK5(CH_WORD i)
	{
		if (i.h >= 0xa8 && i.h <= 0xa9)
		{
			if (i.l >= 0x40 && i.l <= 0xa0 && i.l != 0x7f) return true;
		}
		return false;
	}

	/*
	 * 2012-3-22参考TRC GBK/50 第 50 区 (自造冷僻字) -> EBCDIC GBK: 0xF8A1 --> 0xF8FE
	 */
	private static boolean is_GBK50(CH_WORD i)
	{
		if (i.h >= 0xa1 && i.h <= 0xa7)
		{
			if (i.l >= 0x40 && i.l <= 0x7e) { return true; }
			if (i.l >= 0x80 && i.l <= 0xa0) { return true; }
		}
		if ((i.h >= 0xaa && i.h <= 0xaf) || (i.h >= 0xf8 && i.h <= 0xfe))
		{
			if (i.l >= 0xa1 && i.l <= 0xfe) { return true; }
		}
		return false;
	}

	// GBK/1: GB2312 - 符号区
	// GBK : A1A1 --> A9FE
	private static CH_WORD GBK1_to_EBC1(CH_WORD i)
	{
		int h = i.h - 0xa1;
		int l = i.l - 0xa1;
		CH_WORD o = new CH_WORD();
		o.h = GBK1_to_EBC1_Table[h][l * 2];
		o.l = GBK1_to_EBC1_Table[h][l * 2 + 1];

		return o;
	}

	// GBK2 --> EBCDIC
	// GBK : B0A1 --> F7FE
	// EBC : 48A0 --> 6C9F HIGH (48 , 6C ) LOW ( 41 , FD )
	private static CH_WORD GBK2_to_EBC2(CH_WORD i)
	{
		int h, l;

		h = i.h - 0xb0;
		if (h % 2 != 0) h++;
		h /= 2;

		h += 0x48;
		if (i.h % 2 != 0)
		{
			if (i.l < 0xe0) l = i.l - 0x60;
			else l = i.l - 0x5f;
		}
		else l = i.l - 1;

		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;

		return o;
	}

	// GBK/3 第 3 区 -> EBCDIC
	// GBK: 0x8140 --> 0xA0FE ( 不包括 xx7F )
	private static CH_WORD GBK3_to_EBC3(CH_WORD i)
	{
		int l = (int) (i.l + (i.h - 0x81) * 2 + 1);
		if ((l >= 0x80) && (i.l < 0x80)) l += 1;
		int h = i.h;
		if (l >= 0xfe)
		{
			l = l - 0xfe + 0x41;
			h += 1;
		}
		// 就一个 a0fe -> a180
		if (l == 0x80) l += 1;
		// GBK 的xx7f 替换为 xx40,但是测试结果不行，还得保留 xx7f
		// if( o->l == 0x7f ) l = 0x40;
		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;

		return o;
	}

	// GBK/4 第 4 区 -> EBCDIC
	// GBK: 0xAA40 --> 0xFEA0 ( 不包括 xx7F )
	private static CH_WORD GBK4_to_EBC4(CH_WORD i)
	{
		int h, l = 0;
		int N;
		int a = (i.h << 8) + i.l;
		CH_WORD o = new CH_WORD();
		if (a < 0xfd9c)
		{
			N = (i.h - 0xaa) * 0x60 + (i.l - 0x40) - ((i.l >= 0x80) ? 1 : 0);
			if (N < 0x7c)
			{
				h = 0xa1;
				l = 0x82 + N;
			}
			else
			{
				h = (N - 0x7c) / 0xbc + 0xa2;
				l = (N - 0x7c) % 0xbc + 0x41;
				if (l >= 0x80) l += 1;
			}
		}
		else
		{
			h = 0xce;
			if (i.h == 0xfd) l = i.l - 0x9c + 0x41;
			if (i.h == 0xfe)
			{
				l = i.l + 6;
				if (l >= 0x80 && l <= 0x84) l += 1;
			}
		}

		// GBK 的xx7f 替换为 xx40,但是测试结果不行，还得保留 xx7f
		// if( o->l == 0x7f ) l = 0x40;
		o.h = h;
		o.l = l;
		return o;
	}

	// GBK/5 ，无规律区 -> EBCDIC
	// GBK: 0xA840 --> 0xA9A0 ( 不包括 xx7F )
	private static CH_WORD GBK5_to_EBC5(CH_WORD i)
	{
		int h = i.h - 0xa8;
		int l = i.l - 0x40;
		CH_WORD o = new CH_WORD();
		o.h = GBK5_to_EBC5_Table[h][l * 2];
		o.l = GBK5_to_EBC5_Table[h][l * 2 + 1];
		return o;
	}

	// 2012-3-22参考TRC
	/*
	 * GBK/50，自造字转码区：共支持1894个冷僻字GBK->EBCDIC
	 * GBK:0xAAA1-->0xAFFE(高位：AA-AF，低位：A1-FE)
	 * 　0xF8A1-->0xFEFE(高位：F8-FE，低位：A1-FE)
	 * 　0xA140-->0xA7A0(高位：A1-A7，低位：40-A0(低位不包括xx7F))
	 */
	private static CH_WORD GBK50_to_EBC50(CH_WORD i)
	{
		int h = 0, l = 0;

		if ((i.h >= 0xaa && i.h <= 0xaf) || (i.h >= 0xf8 && i.h <= 0xfe))
		{
			/* 求0xaa-0xaf高位、低位 */
			if (i.h >= 0xaa && i.h <= 0xaf)
			{
				h = (i.h - 0xaa) / 2 + 0x76;

				if (((i.h - 0xaa) % 2) == 0)
				{
					if (i.l >= 0xa1 && i.l <= 0xdf)
					{
						l = i.l - 0x60;
					}
					else
					{
						l = i.l - 0x5f;
					}
				}
				else
				{
					l = i.l - 0x01;
				}
			}
			/* 求0xf8-0xfe高位、低位 */
			else
			{
				h = (i.h - 0xf8) / 2 + 0x79;

				if (((i.h - 0xf8) % 2) == 0)
				{
					if (i.l >= 0xa1 && i.l <= 0xdf)
					{
						l = i.l - 0x60;
					}
					else
					{
						l = i.l - 0x5f;
					}
				}
				else
				{
					l = i.l - 0x01;
				}
			}
		}
		/*--上面完成高位：0xaa-0xaf、0xf8-0xfe区间上传转码----------------------------------*/

		/*----下面进行：A1至A7段的转码----------------------------------------------------------*/
		if (i.h >= 0xa1 && i.h <= 0xa7)
		{
			if (i.h == 0xa1)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x7e)
					{
						l = i.l + 0x60;
						h = 0x7c;
					}
					if (i.l >= 0x80 && i.l <= 0x9e)
					{
						l = i.l + 0x5f;
						h = 0x7c;
					}
					if (i.l >= 0x9f)
					{
						l = i.l - 0x5e;
						h = 0x7d;
					}
				}
			}
			if (i.h == 0xa2)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x7c)
					{
						l = i.l + 0x03;
						h = 0x7d;
					}
					if (i.l >= 0x7d && i.l <= 0x7e)
					{
						l = i.l + 0x04;
						h = 0x7d;
					}
					if (i.l >= 0x80)
					{
						l = i.l + 0x03;
						h = 0x7d;
					}
				}
			}
			if (i.h == 0xa3)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x7e)
					{
						l = i.l + 0x64;
						h = 0x7d;
					}
					if (i.l >= 0x80 && i.l <= 0x9a)
					{
						l = i.l + 0x63;
						h = 0x7d;
					}
					if (i.l >= 0x9b)
					{
						l = i.l - 0x5a;
						h = 0x7e;
					}
				}
			}
			if (i.h == 0xa4)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x78)
					{
						l = i.l + 0x07;
						h = 0x7e;
					}
					if (i.l >= 0x79 && i.l <= 0x7e)
					{
						l = i.l + 0x08;
						h = 0x7e;
					}
					if (i.l >= 0x80)
					{
						l = i.l + 0x07;
						h = 0x7e;
					}
				}
			}
			if (i.h == 0xa5)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x7e)
					{
						l = i.l + 0x68;
						h = 0x7e;
					}
					if (i.l >= 0x80 && i.l <= 0x96)
					{
						l = i.l + 0x67;
						h = 0x7e;
					}
					if (i.l >= 0x97)
					{
						l = i.l - 0x56;
						h = 0x7f;
					}
				}
			}
			if (i.h == 0xa6)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x74)
					{
						l = i.l + 0x0b;
						h = 0x7f;
					}
					if (i.l >= 0x75 && i.l <= 0x7e)
					{
						l = i.l + 0x0c;
						h = 0x7f;
					}
					if (i.l >= 0x80)
					{
						l = i.l + 0x0b;
						h = 0x7f;
					}
				}
			}
			if (i.h == 0xa7)
			{
				if ((i.l >= 0x40) && (i.l <= 0xa0))
				{
					if (i.l <= 0x7e)
					{
						l = i.l + 0x6c;
						h = 0x7f;
					}
					if (i.l >= 0x80 && i.l <= 0x92)
					{
						l = i.l + 0x6b;
						h = 0x7f;
					}
					if (i.l >= 0x93)
					{
						l = i.l - 0x52;
						h = 0x80;
					}
				}
			}
		}
		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;

		return o;
	}

	// EBC1 : 没有规律 ， 所以从对照表中搜索
	public static boolean is_EBC1(CH_WORD i)
	{
		return EBC1_to_GBK1(i) != null;
	}

	// EBCDIC/2
	// EBC : 48A0 --> 6C9F HIGH (48 , 6C ) LOW ( 41 , FD )
	// 是 - 1 不是 - 0
	public static boolean is_EBC2(CH_WORD i)
	{
		int h = i.h;
		int l = i.l;
		if (h == 0x48)
		{
			if (l >= 0xA0 && l <= 0xfd) return true;
		}
		if (h >= 0x49 && h <= 0x6b)
		{
			if (l >= 0x41 && l <= 0xfd && l != 0x80) return true;
		}
		if (h == 0x6c)
		{
			if (l >= 0x41 && l <= 0x9f && l != 0x80) return true;
		}
		return false;
	}

	// EBCDIC/3 --> GBK3
	// EBCDIC: 0x8141 --> 0xa0fd + 0xa181
	// 不包括 xx80
	// 是 - 1 不是 - 0
	private static boolean is_EBC3(CH_WORD i)
	{
		int h = i.h;
		int l = i.l;

		if (h >= 0x81 && h <= 0xa0)
		{
			if (l >= 0x41 && l <= 0xfd && l != 0x80) { return true; }
		}
		/* if( h == 0xa1 && l == 0x81 ) return 1; */
		if (h == 0xa1 && l <= 0x81) return true;
		return false;
	}

	// EBCDIC/4
	// A182 --> CEA6 ( 去掉 CC68 --> CDxx 和 xx80)
	private static boolean is_EBC4(CH_WORD i)
	{
		int h = i.h;
		int l = i.l;

		if (h == 0xa1)
		{
			if (l >= 0x82 && l <= 0xfd) return true;
		}
		else if (h > 0xa1 && h < 0xcc)
		{
			if (l >= 0x41 && l <= 0xfd && l != 0x80) return true;
		}
		else if (h == 0xcc)
		{
			if (l >= 0x41 && l <= 0x67) return true;
		}
		else if (h == 0xce)
		{
			if (l >= 0x41 && l <= 0xa6 && l != 0x80) return true;
		}

		return false;
	}

	// EBC5 : 没有规律 ， 所以从对照表中搜索
	private static boolean is_EBC5(CH_WORD i)
	{
		return EBC5_to_GBK5(i) != null;
	}

	// 2012-3-22参考TRC
	/*
	 * 验证是否为1894自造字区域EBCDIC-->GBK不包括xx80是-1不是-0
	 */
	private static boolean is_EBC50(CH_WORD i)
	{
		int h, l;

		h = i.h;
		l = i.l;

		if (h >= 0x76 && h <= 0x7f)
		{
			if (l >= 0x41 && l <= 0xfd && l != 0x80) { return true; }
		}
		if ((h == 0x80) && (l >= 0x41 && l <= 0x4e)) { return true; }
		if (h == 0xfe && l == 0xfe) { return true; }

		return false;
	}

	// EBCDIC/1 --> GBK1
	// 没有规律,所以只能用预先定义好的对照表
	private static CH_WORD EBC1_to_GBK1(CH_WORD i)
	{
		int h, l;
		for (h = 0; h < 9; h++)
		{
			for (l = 0; l < 94; l++)
			{
				if (GBK1_to_EBC1_Table[h][l * 2] == i.h && GBK1_to_EBC1_Table[h][l * 2 + 1] == i.l)
				{
					CH_WORD o = new CH_WORD();
					o.h = h + 0xa1;
					o.l = l + 0xa1;
					return o;
				}
			}
		}

		return null;
	}

	// EBCDIC/2 --> GBK2
	// EBC : 48A0 --> 6C9F HIGH (48 , 6C ) LOW ( 41 , FD )
	private static CH_WORD EBC2_to_GBK2(CH_WORD i)
	{
		int h, l;
		if (i.h != 0x48)
		{
			h = i.h - 0x48;
			h *= 2;
			if (i.l <= 0x9f) h--;
			h = h + 0xb0;
			if (i.l <= 0x9f)
			{
				if (i.l < 0x81) l = i.l + 0x60;
				else l = i.l + 0x5f;
			}
			else l = i.l + 1;
		}
		else
		{
			h = 0xb0;
			l = i.l + 1;
		}
		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;
		return o;
	}

	// EBCDIC/3 --> GBK3
	// EBCDIC: 0x8141 --> 0xa0fd + 0xa181
	// 不包括 0x80xx
	private static CH_WORD EBC3_to_GBK3(CH_WORD i)
	{
		int h, l;
		l = i.l - ((i.h - 0x81) * 2 + 1);
		if (i.l >= 0x80 && l <= 0x7f) l--;
		h = i.h;
		if (l < 0x40)
		{
			l = i.l - 0x41 + 0x100 - ((i.h - 0x81) * 2 + 1);
			h = i.h - 1;
		}
		if (i.h == 0xa1 && i.l == 0x81) l--;
		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;

		return o;
	}

	// EBCDIC/4 --> GBK3
	// EBCDIC: A82 --> CEA6 ( 去掉 CC68 --> CDxx 和 xx80)
	// GBK : AA40 --> FEA0 ( 去掉 xx7F)
	private static CH_WORD EBC4_to_GBK4(CH_WORD i)
	{
		int N;
		int h, l;

		if (i.h == 0xa1)
		{
			N = i.l - 0x82;
		}
		else if (i.h >= 0xa2 && i.h <= 0xcc)
		{
			N = (i.h - 0xa2) * 0xbc + (i.l - 0x41) + 0x7c;
			N -= (i.l >= 0x80) ? 1 : 0;
		}
		else
		{
			N = (i.h - 0xa2 - 1 - 1) * 0xbc + (i.l - 0x41) + 0x7c + 0x27;
			N -= (i.l >= 0x80) ? 1 : 0;
		}
		h = N / 0x60 + 0xaa;
		l = N % 0x60 + 0x40;
		if (l >= 0x7f) l += 1;
		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;

		return o;
	}

	// EBCDIC/5 --> GBK5
	// 没有规律,所以只能用预先定义好的对照表
	private static CH_WORD EBC5_to_GBK5(CH_WORD i)
	{
		int h, l;
		CH_WORD o = new CH_WORD();

		for (h = 0; h <= 1; h++)
		{
			for (l = 0; l < 0x60; l++)
			{
				if (GBK5_to_EBC5_Table[h][l * 2] == i.h && GBK5_to_EBC5_Table[h][l * 2 + 1] == i.l)
				{
					// by chi
					// CH_WORD o = new CH_WORD();
					// end
					o.h = h + 0xa8;
					o.l = l + 0x40;

					return o;
				}
			}
		}

		return null;
	}

	/*
	 * 2012-3-22参考TRC 自造字区，共支持1894个冷僻字EBCDIC/50-->GBK50不包括0x80xx
	 */
	private static CH_WORD EBC50_to_GBK50(CH_WORD i)
	{
		int h = 0, l = 0;
		if ((i.h >= 0x76 && i.h <= 0x78) || (i.h >= 0x79 && i.h <= 0x7b)
				|| (i.h == 0x7c && i.l <= 0x9f))
		{
			if (i.h >= 0x76 && i.h <= 0x78) h = ((i.h - 0x76) * 2) + 0xaa;
			// 共用算法求EBC：0x76-0x78转出ASC：0xaa-0xaf高位
			else h = ((i.h - 0x79) * 2) + 0xf8;
			// 共用算法 求EBC：0x79-0x7c转出ASC：0xf8-0xfe高位

			// EBCD:7c9f正常转为ASC:fefe，上传是ASC:fefe转码为EBC:7c9f
			if (i.l >= 0x41 && i.l <= 0x7f)
			{
				l = i.l + 0x60;
			}

			if (i.l >= 0x81 && i.l <= 0x9f)
			{
				l = i.l + 0x5f;
			}

			if (i.l >= 0xa0 && i.l <= 0xfd)
			{
				h = h + 0x01;
				// 求0xaa-0xaf,0xf8-0xfe的最终高位
				l = i.l + 0x01;
			}
		}
		// EBCD:fefe时也要转码为ASC:fefe
		if (i.h == 0xfe && i.l == 0xfe)
		{
			h = 0xfe;
			l = 0xfe;
		}
		// --------上面完成高位：0xaa-0xaf、0xf8-0xfe区间下传转码，下面则进行a1-a7的下传
		if ((i.h >= 0x7c && i.l >= 0xa0) || (i.h >= 0x7d && i.h <= 0x7f) || (i.h == 0x80))
		{
			// --7c
			if (i.h == 0x7c)
			{
				h = 0xa1;

				if (i.l <= 0xde) l = i.l - 0x60;
				else l = i.l - 0x5f;
			}
			// --7d
			if (i.h == 0x7d)
			{
				if (i.l >= 0xa4)
				{
					h = 0xa3;

					if (i.l <= 0xe2) l = i.l - 0x64;
					else l = i.l - 0x63;
				}
				if (i.l <= 0x42)
				{
					h = 0xa1;
					l = i.l + 0x5e;
				}
				if ((i.l >= 0x43) && (i.l <= 0xa3))
				{
					h = 0xa2;
					l = i.l - 0x03;

					if ((i.l >= 0x81) && (i.l <= 0x82))
					{
						l = l - 0x01;
					}
				}
			}
			// --7e
			if (i.h == 0x7e)
			{
				if (i.l >= 0xa8)
				{
					h = 0xa5;

					if (i.l <= 0xe6) l = i.l - 0x68;
					else l = i.l - 0x67;

				}
				if (i.l <= 0x46)
				{
					h = 0xa3;
					l = i.l + 0x5a;
				}
				if ((i.l >= 0x47) && (i.l <= 0xa7))
				{
					h = 0xa4;
					l = i.l - 0x07;
					if ((i.l >= 0x81) && (i.l <= 0x86)) l = l - 0x01;
				}
			}
			// --7f
			if (i.h == 0x7f)
			{
				if (i.l >= 0xac)
				{
					h = 0xa7;

					if (i.l <= 0xea) l = i.l - 0x6c;
					else l = i.l - 0x6b;
				}
				if (i.l <= 0x4a)
				{
					h = 0xa5;
					l = i.l + 0x56;
				}
				if ((i.l >= 0x4b) && (i.l <= 0xab))
				{
					h = 0xa6;
					l = i.l - 0x0b;
					if ((i.l >= 0x81) && (i.l <= 0x8a)) l = l - 0x01;
				}
			}
		}
		// 对EBCDIC码转回ASC时直接运算
		if (i.h == 0x80)
		{
			h = 0xa7;
			l = i.l + 0x52;
		}
		// a1-a7结束
		CH_WORD o = new CH_WORD();
		o.h = h;
		o.l = l;

		return o;
	}

	private static int a2e_tab[] = {
			// IBM-1047 从 apche 服务器程序中拿来的
			// 为了解决 回车 '\n' 的正确转码
			0x00, 0x01, 0x02, 0x03, 0x37, 0x2d, 0x2e, 0x2f, // 00-0f:
			0x16, 0x05, 0x15, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, // ................
			0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26, // 10-1f:
			0x18, 0x19, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f, // ................
			0x40, 0x5a, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d, // 20-2f:
			0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61, // !"#$%&'()*+,-./
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, // 30-3f:
			0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f, // 0123456789:;<=>?
			0x7c, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, // 40-4f:
			0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, // @ABCDEFGHIJKLMNO
			0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, // 50-5f:
			// 0xe7, 0xe8, 0xe9, 0xad, 0xe0, 0xbd, 0x5f, 0x6d, //
			// PQRSTUVWXYZ[\]^_
			0xe7, 0xe8, 0xe9, 0xba, 0xb2, 0xbb, 0xb0, 0x6d, // PQRSTUVWXYZ[\]^_
			0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, // 60-6f:
			0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, // `abcdefghijklmno
			0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, // 70-7f:
			// 0xa7, 0xa8, 0xa9, 0xc0, 0x4f, 0xd0, 0xa1, 0x07, //
			// pqrstuvwxyz{|}~.
			0xa7, 0xa8, 0xa9, 0xc0, 0x4f, 0xd0, 0xa0, 0x07, // pqrstuvwxyz{|}~.
			0x20, 0x21, 0x22, 0x23, 0x24, 0x04, 0x06, 0x08, // 80-8f:
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x09, 0x0a, 0x14, // ................
			0x30, 0x31, 0x25, 0x33, 0x34, 0x35, 0x36, 0x17, // 90-9f:
			0x38, 0x39, 0x3a, 0x3b, 0x1a, 0x1b, 0x3e, 0xff, // ................
			0x41, 0xaa, 0x4a, 0xb1, 0x9f, 0xb2, 0x6a, 0xb5, // a0-af:
			0xbb, 0xb4, 0x9a, 0x8a, 0xb0, 0xca, 0xaf, 0xbc, // ................
			0x90, 0x8f, 0xea, 0xfa, 0xbe, 0xa0, 0xb6, 0xb3, // b0-bf:
			0x9d, 0xda, 0x9b, 0x8b, 0xb7, 0xb8, 0xb9, 0xab, // ................
			0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9e, 0x68, // c0-cf:
			0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77, // ................
			0xac, 0x69, 0xed, 0xee, 0xeb, 0xef, 0xec, 0xbf, // d0-df:
			0x80, 0xfd, 0xfe, 0xfb, 0xfc, 0xba, 0xae, 0x59, // ................
			0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9c, 0x48, // e0-ef:
			0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57, // ................
			0x8c, 0x49, 0xcd, 0xce, 0xcb, 0xcf, 0xcc, 0xe1, // f0-ff:
			0x70, 0xdd, 0xde, 0xdb, 0xdc, 0x8d, 0x8e, 0xdf // ................
	};

	// ASCII --> EBCDIC
	private static int char_a2e(int in_ch)
	{
		return (a2e_tab[in_ch]);
	}

	public static int e2a_tab[] = { // IBM - 1047 的转码表

	0x00, 0x01, 0x02, 0x03, 0x85, 0x09, 0x86, 0x7f, // 00-0f:
			0x87, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, // ................
			0x10, 0x11, 0x12, 0x13, 0x8f, 0x0a, 0x08, 0x97, // 10-1f:
			0x18, 0x19, 0x9c, 0x9d, 0x1c, 0x1d, 0x1e, 0x1f, // ................
			0x80, 0x81, 0x82, 0x83, 0x84, 0x92, 0x17, 0x1b, // 20-2f:
			0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07, // ................
			0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, // 30-3f:
			0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a, // ................
			0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5, // 40-4f:
			0xe7, 0xf1, 0xa2, 0x2e, 0x3c, 0x28, 0x2b, 0x7c, // ...........<(+|
			0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef, // 50-5f:
			0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x5e, // &.........!$*);^
			0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5, // 60-6f:
			0xc7, 0xd1, 0xa6, 0x2c, 0x25, 0x5f, 0x3e, 0x3f, // -/.........,%_>?
			0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf, // 70-7f:
			0xcc, 0x60, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22, // .........`:#@'="
			0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, // 80-8f:
			0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1, // .abcdefghi......
			0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, // 90-9f:
			0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4, // .jklmnopqr......
			// 0xb5, 0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, // a0-af:
			0x7e, 0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, // a0-af:
			0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0x5b, 0xde, 0xae, // .~stuvwxyz...[..
			// 0xac, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc, // b0-bf:
			0x5e, 0xa3, 0x5c, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc, // b0-bf:
			// 0xbd, 0xbe, 0xdd, 0xa8, 0xaf, 0x5d, 0xb4, 0xd7, //
			// .............]..
			0xbd, 0xbe, 0x5b, 0x5d, 0xaf, 0x5d, 0xb4, 0xd7, // ..........[].x..
			0x7b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, // c0-cf:
			0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5, // {ABCDEFGHI......
			0x7d, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, // d0-df:
			0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xf9, 0xfa, 0xff, // }JKLMNOPQR......
			0x5c, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, // e0-ef:
			0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5, // \.STUVWXYZ......
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, // f0-ff:
			0x38, 0x39, 0xb3, 0xdb, 0xdc, 0xd9, 0xda, 0x9f // 0123456789......
	};

	// convert EBCDIC code into ASCII code
	private static int char_e2a(int in_ch)
	{
		return (e2a_tab[in_ch]);
	}

	public static CH_WORD GBK_to_EBC(CH_WORD i)
	{
		if (is_GBKinDict(i)) return GBK0_to_EBC0(i); // 字库最优先
		else if (is_GBK2(i)) return GBK2_to_EBC2(i); // 最常用
		else if (is_GBK1(i)) return GBK1_to_EBC1(i);
		else if (is_GBK3(i)) return GBK3_to_EBC3(i);
		else if (is_GBK4(i)) return GBK4_to_EBC4(i);
		else if (is_GBK50(i)) return GBK50_to_EBC50(i); // 2012-3-22参考TRC,自造词区域
		else if (is_GBK5(i)) return GBK5_to_EBC5(i); // 没有规律放在最后判断
		return null;
	}

	private static boolean is_GBKinDict(CH_WORD i)
	{
		if (EBCDDict.gbk2bcd_binarySearch((i.h << 8) + i.l) < 0) return false;
		else return true;
	}

	private static CH_WORD GBK0_to_EBC0(CH_WORD i)
	{
		int ch = EBCDDict.gbk2bcd_binarySearch((i.h << 8) + i.l);
		CH_WORD o = new CH_WORD();
		o.h = (ch >>> 8) & 0XFF;
		o.l = ch & 0XFF;
		return o;
	}

	public static CH_WORD EBC_to_GBK(CH_WORD i)
	{
		if (is_EBCinDict(i)) return EBC0_to_GBK0(i); // 字库最优先
		else if (is_EBC2(i)) return EBC2_to_GBK2(i); // 最常用
		else if (is_EBC3(i)) return EBC3_to_GBK3(i);
		else if (is_EBC4(i)) return EBC4_to_GBK4(i);
		else if (is_EBC1(i)) return EBC1_to_GBK1(i);
		else if (is_EBC50(i)) return EBC50_to_GBK50(i); // 2012-3-22参考TRC,自造词区域
		else if (is_EBC5(i)) return EBC5_to_GBK5(i); // 没有规律放在最后判断
		return null;
	}

	private static CH_WORD EBC0_to_GBK0(CH_WORD i)
	{
		int ch = EBCDDict.bcd2gbk_binarySearch((i.h << 8) + i.l);
		CH_WORD o = new CH_WORD();
		o.h = (ch >>> 8) & 0XFF;
		o.l = ch & 0XFF;
		return o;
	}

	private static boolean is_EBCinDict(CH_WORD i)
	{
		if (EBCDDict.bcd2gbk_binarySearch((i.h << 8) + i.l) < 0) return false;
		else return true;
	}

	public static void main(String[] args)
	{
		byte[] bytes1 = EBCDUtil.gbk2bcd("aa156f冀中能源峰峰集团 武安市南澈犹矿有限公司肢A3| ");
		System.out.println(EBCDUtil.bcd2gbk(bytes1));
	}

	// 以下方法是处理EBCD编码中的P类型，也就是压缩类型
	/*
	 * ebcd p类型转换为gbk
	 * 
	 * @param ebc ebc字节数组
	 * 
	 * @param ebc_len ebc字节数组长度
	 * 
	 * @param asc_len 转换后的asc长度，接口约定
	 */
	public static String bcdp2gbk(byte[] ebc, int asc_len) throws Exception
	{
		if (ebc == null || ebc.length == 0) return StringX.EMPTY_STRING;
		int ebc_len = ebc.length;
		byte[] asc = new byte[asc_len];

		for (int i = 0; i < asc_len; ++i)
		{
			asc[i] = 0x20; // 补足空格
		}

		int ebc_offset = 0;
		int asc_offset = 0;
		int negativeFlag = 0; // 正负标志

		boolean start_flag = true; // 第一次标志

		int tmplast = ebc[(ebc_len - 1)];
		if (tmplast < 0) tmplast += 256;

		int[] intValues = int2hexInts(tmplast);

		if (intValues[1] != 15)
		{
			negativeFlag = 1;
		}

		while (ebc_offset < ebc_len)
		{
			int bvalue = ebc[ebc_offset];
			if (bvalue < 0) bvalue += 256;

			intValues = int2hexInts(bvalue);

			if (ebc_offset < ebc_len - 1)
			{
				if (intValues[0] != 0)
				{
					if ((negativeFlag == 1) && start_flag)
					{
						asc[asc_offset] = 0x2D; // 负号
						asc[(asc_offset + 1)] = (byte) (intValues[0] + 0x30);
						start_flag = false;
						asc_offset += 2;
					}
					else
					{
						asc[asc_offset] = (byte) (intValues[0] + 0x30);
						start_flag = false;
						++asc_offset;
					}
				}
				else if (!start_flag)
				{
					asc[asc_offset] = (byte) (intValues[0] + 0x30);
					++asc_offset;
				}

				if (intValues[1] != 0)
				{
					if ((negativeFlag == 1) && start_flag)
					{
						asc[asc_offset] = 0x2D;
						asc[(asc_offset + 1)] = (byte) (intValues[1] + 0x30);

						start_flag = false;
						asc_offset += 2;
					}
					else
					{
						asc[asc_offset] = (byte) (intValues[1] + 0x30);
						start_flag = false;
						++asc_offset;
					}
				}
				else if (!start_flag)
				{
					asc[asc_offset] = (byte) (intValues[1] + 0x30);
					++asc_offset;
				}
				++ebc_offset;
			}

			if (ebc_offset != ebc_len - 1) continue;
			bvalue = ebc[ebc_offset];
			if (bvalue < 0)
			{
				bvalue += 256;
			}

			intValues = int2hexInts(bvalue);

			if (intValues[0] != 0)
			{
				if ((negativeFlag == 1) && start_flag)
				{
					asc[asc_offset] = 0x2D;
					asc[(asc_offset + 1)] = (byte) (intValues[0] + 0x30);
					start_flag = false;
				}
				else
				{
					asc[asc_offset] = (byte) (intValues[0] + 0x30);
					start_flag = false;
				}
			}
			else
			{
				asc[asc_offset] = (byte) (intValues[0] + 0x30);
			}
			++ebc_offset;
		}

		byte[] bTmp = new byte[asc_len];
		for (int i = 0; i < asc_len; ++i)
		{
			bTmp[i] = 32;
		}

		for (int i = 0; i <= asc_offset; ++i)
		{
			if (asc_len - asc_offset - 1 + i > asc_len) break;
			if (asc_len - asc_offset - 1 + i < 0) break;
			bTmp[(asc_len - asc_offset - 1 + i)] = asc[i];
		}

		for (int i = 0; i < asc_len; ++i)
			asc[i] = 0;
		for (int i = 0; i < asc_len; ++i)
			asc[i] = bTmp[i];
		return new String(asc, Common.CHARSET_GBK);
	}

	/*
	 * ebcd p类型转换为gbk
	 * 
	 * @param gbk gbk字符串
	 */
	public static byte[] gbk2bcdp(String gbk) throws Exception
	{
		if (StringX.nullity(gbk)) return new byte[0];
		byte[] asc = gbk.getBytes(Common.CHARSET_GBK);
		int len = asc.length;
		return gbk2bcdp(asc, len, (len / 2 + 1));
	}

	/*
	 * ebcd p类型转换为gbk
	 * 
	 * @param asc asc字节数组
	 * 
	 * @param asc_len asc字节数组长度
	 * 
	 * @param ebc_len ebc的长度=(asc_len/2)+1
	 */
	private static byte[] gbk2bcdp(byte[] asc, int asc_len, int ebc_len)
	{
		byte[] ebc = new byte[ebc_len]; // 返回的ebc
		int negativeFlag = 0; // 负数标志

		for (int i = 0; i < ebc_len; i++)
		{
			ebc[i] = 0; // 填充返回值为 null
		}

		byte[] bTmp = new byte[asc_len * 2];
		for (int i = 1; i < bTmp.length; ++i)
		{
			bTmp[i] = 0;
		}

		int ebc_hex_len = ebc_len * 2; // ebc的hex长度
		int len = ebc_hex_len - 2;
		for (int i = asc_len - 1; i >= 0; i = i - 1)
		{
			if (asc[i] == 0x2D) negativeFlag = 1; // 有负号表示负数
			if ((asc[i] == 0x2D) || (asc[i] == 0x2E)) // 负号或者小数点
			continue;
			if (asc[i] == 0x20) bTmp[len] = 0; // 空格
			else bTmp[len] = asc[i];
			--len;
		}

		int h = 0; // 高位
		int l = 0; // 低位
		for (int i = 0; i < ebc_len; ++i)
		{
			h = 0;
			l = 0;
			if (bTmp[i * 2] > 0) h = bTmp[i * 2] - 0x30;
			else h = bTmp[i * 2];

			if (bTmp[(i * 2 + 1)] > 0) l = bTmp[(i * 2 + 1)] - 0x30;
			else l = bTmp[(i * 2 + 1)];

			if (i * 2 + 1 == ebc_hex_len - 1)
			{
				if (negativeFlag == 1) l = 0x0D;
				else l = 15;
			}
			ebc[i] = (byte) (h * 16 + l);
		}
		return ebc;
	}

	/*
	 * 把int 数值转换为16进制，并拆分为 int[2],例30的16制为1E,则int[0]=1,int[1]=14
	 */
	private static int[] int2hexInts(int iValue)
	{
		int[] oValue = new int[2];
		oValue[0] = (iValue / 16);
		oValue[1] = (iValue % 16);
		return oValue;
	}
}
